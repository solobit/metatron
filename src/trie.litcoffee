
    words = ['dirty', 'bastard', 'old', 'friend', 'of', 'mine']

# JavaScript Structures: Trie Performance

## Introduction to Tries
> Source: <http://ejohn.org/blog/javascript-trie-performance-analysis/>

Discussing dictionary lookups in JavaScript, the unanimous consensus
seemed to be that utilizing Trie would result in additional space
savings and yield performance benefits.

A Trie is a relatively simple data structure. At its simplest form
you’re building a tree-like structure where each final leaf results in a
complete word. This allows for some very efficient use of file size –
reducing common prefixes in words quite easily.

## In search of solutions
> Source: <http://ejohn.org/blog/javascript-trie-performance-analysis/>

I looked through a number of JavaScript Trie solutions and yet was not
terribly pleased with them. They were either total overkill (including
large object structures and functionality far beyond what I needed) or
weren’t compressing the resulting data structure enough. The closest in
functionality that I found, to what I wanted, was what was written by
Henrik Hinrichs, called [wordlistparser][01]. Wordlistparser creates a
simple Trie structure using Node.js.

I’ve dumped my work-in-progress [JavaScript Trie Generator][02] up on
Github (note that it requires Node.js to run).

## Generating a Trie

The basic Trie generation functionality is as follows (note that I use
`0` or `$:0` to indicate a complete word):

[01]: <https://github.com/mutaphysis/wordlistparser>
[02]: <https://github.com/jeresig/trie-js>


Go through all the words in the dictionary

    #i = 0
    #l = words.length
    #while i < l
    for i in words.length - 1
      
Get all the letters that we need

        word    = words[i]
        letters = word.split("")
        cur     = trie
      
Loop through the letters

        #j = 0

        #while j < letters.length
        for j in letters.length - 1

            letter = letters[j]
            pos    = cur[letter]
            
If nothing exists for this letter, create a leaf. If it's the end of the
word, set a 0, otherwise make an object so we can continue.

            cur = cur[letter] = (if j is letters.length - 1 then 0 else {}) unless pos? 
            
If a final leaf already exists we need to turn it into an object to
continue traversing.

            cur = cur[letter] = $: 0 if pos is 0 
            
Otherwise there is nothing to be set, so continue on

            cur = cur[letter]
            #j++
        #i++

Note that I (Supersym) converted the Javascript on this page to literate
CS. Low level `while loops` were substituted for list comprehensions
over an array of numbers words or letters.

## Optimizing the Structure
> Source: <http://ejohn.org/blog/javascript-trie-performance-analysis/>

While this is fine I wanted to go a step further. Rather than having
single letters at every leaf of the tree I saw much room for
optimization. Dave Ward posted a sample tree structure which was rather
similar to what was generated by Henrik’s code (only Henrik’s code used
`$:1` instead of `end:true` to save bytes). Looking at the resulting
tree structure provided by Dave I was not terribly pleased with the
resulting number of objects or code length.

**Code posted by Dave Ward**

```js

var trie = {
    b: {
        a: {
            r: {
                end: true,
                s: {
                    end: true
                }
            }
        }
    },
    f: {
        o: {
            o: {
                end: true
            }
        }
    },
    r: {
        a: {
            t: {
                end: true,
                e: {
                    end: true
                }
            }
        }
    }
};
```

I saw that letters that only had a single child could be reduced into a
single string. `r` `a` `t` could just become `rat`. Additionally there
was no need to have a bulky `{$:1}` structure just to denote the end of
a word when you could just use the number 1 to indicate that as well.

    # Optimize a Trie structure
    optimize = (cur) ->

        num = 0
        
Go through all the leaves in this branch and, ...

        for node of cur
          
...if the leaf has children...

            if typeof cur[node] is "object"
              
continue the optimization even deeper.

                ret = optimize(cur[node])

The child leaf only had one child and was "compressed" as a result, thus
remove the current leaf and remember the new name and replace it with
the revised one.

                if ret

                    delete cur[node]

                    node = node + ret.name

                    cur[node] = ret.value

Keep track of how many leaf nodes there are

            num++

If only one leaf is present, compress it

        if num is 1
            name: node
            value: cur[node]





## TODO


http://ejohn.org/blog/javascript-trie-performance-analysis/



